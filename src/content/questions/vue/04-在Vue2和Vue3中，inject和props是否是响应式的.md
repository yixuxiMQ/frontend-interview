---
id: 'vue-004'
title: '在Vue2和Vue3中，inject和props是否是响应式的'
category: 'vue'
tags: ['provide/inject', 'props']
difficulty: 'medium'
---

## **一、在Vue2和Vue3中，inject和props是否是响应式的**

1. **Props 是响应式的吗？**

   **结论：是的。** 无论是 Vue 2 还是 Vue 3，`props` 都是响应式的。

   #### 为什么？

   - **单向数据流：** Vue 的设计核心是“向下传递数据”。父组件更新传入的值时，子组件的 `props` 会自动更新。
   - **底层实现：**
     - 在 **Vue 2** 中，Vue 内部对 `props` 对象进行了 `Object.defineProperty` 的劫持。
     - 在 **Vue 3** 中，`props` 本身就是一个被 `proxy` 包装的响应式对象。
   - **注意点：** 你不能在子组件里直接修改 `prop` 的值（会报错），但如果父组件改了，子组件一定会感知到并触发重新渲染。

2. **Inject 是响应式的吗？**

   **结论：默认不是，但可以实现**。

   在 Vue 2 和 Vue 3 中，`Provide/Inject` 默认情况下**不保证**注入值的响应性。

    **为什么默认不响应？**

   Vue 的官方文档明确指出：`provide` 和 `inject` 绑定并不是可响应的。这是为了防止开发者滥用该功能，导致数据流向变得难以追踪。

   **如何让它变成响应式？**

   这取决于你传递的是“值”还是“响应式引用”：

   | 场景                          | 是否响应式   | 原因                                                         |
   | ----------------------------- | ------------ | ------------------------------------------------------------ |
   | **传递普通字符串/数字**       | **否**       | 传递的是值的快照，父组件修改后，子组件拿到的依然是旧值。     |
   | 传递一个对象                  | 是 (间接)    | 由于 JavaScript 对象的引用特性，子组件访问对象的属性时能拿到更新后的值。 |
   | Vue 3 传递 `ref` / `reactive` | 是           | **这是 Vue 3 的标准做法。** 你直接提供一个响应式引用，注入方自然能保持响应。 |
   | Vue 2 传递组件实例 (`this`)   | 是（不推荐） | 将整个父组件实例 `provide` 出去，子组件访问 `this.xxx` 是响应式的，但会导致严重耦合。 |

3. **Vue 2 vs Vue 3 的实现差异**

   **Vue 2 中的实现**

   如果你想在 Vue 2 中实现 Inject 的响应式，通常需要传递一个对象：

   ```javascript
   // 父组件
   provide() {
     return {
       sharedData: this.state // 假设 state 是一个对象 { count: 1 }
     };
   }
   ```

   **Vue 3 中的实现 (组合式 API)**

   Vue 3 更加直观。你可以直接提供一个 `ref`：

   ```javascript
   // 父组件
   const count = ref(0);
   provide('count', count);
   
   // 子组件
   const count = inject('count'); // 此时 count 依然是 ref，具有响应性
   ```

4. ### 深度原理剖析：为什么 Prop 和 Inject 待遇不同？

   1. **链路明确性**：`Props` 是明确的父子关系，Vue 引擎在渲染每个子组件时，会自动建立 `prop` 到渲染函数的依赖追踪。
   2. **依赖追踪的缺失**：`Inject` 是跨级查找。在 Vue 2 的设计中，`inject` 只是在初始化时简单的执行了一次“向上查找并赋值”。它没有像 `computed` 或 `watch` 那样在查找链条上建立一套自动更新的机制。
   3. **引用机制**：在 Vue 3 中，由于 `ref` 和 `reactive` 的本质是对象（Proxy 或具有 `.value` 的对象），当 `inject` 拿到这个对象引用时，后续的读写依然会触发 Proxy 的拦截，从而实现了“看起来”是 Inject 响应式的效果。

5. ### 总结建议

   - **Props**：放心使用，它是天然响应式的。
   - **Inject**：如果你需要它响应，请在父组件 `provide` 时传入一个 **`reactive` 对象**或 **`ref`**。